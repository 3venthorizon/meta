package com.devlambda.meta.persistence;


import static java.util.stream.Collectors.*;
import static java.util.function.Function.identity;

import static com.devlambda.meta.persistence.MetaRepo.*;

import java.sql.Blob;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Savepoint;
import java.sql.Statement;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.function.Supplier;

import com.devlambda.meta.Property;
import com.devlambda.meta.Type;


/**
 * Meta Persistence API
 * <p>
 * This class is the engine and core database integration API.
 * </p>
 * <p>
 * Getting started:
 * <ol>
 * <li>Create or prepare your database with tables and records.
 * <li>Create an instance of this class and keep a application global reference of it:
 * <div>
 *    String jdbcUrl = "jdbc:h2:mem:testdb";<br>
 *    Supplier&lt;Connection&gt; connector = Connector.connectionProvider(jdbcUrl);<br>
 *    MPA mpa = new MPA(connector);<br>
 * </div>
 * </li>
 * <li>Create a Plain Old Java Object to represent a table-column definition: 
 * <div>
 *    //imports ...<br>
 *    <br>
 *    public class Person {<br>
 *    &emsp;private Long id; //auto increment primary key<br>
 *    &emsp;private String name;<br>
 *    &emsp;private String lastName;<br>
 *    &emsp;private Date birthDate;<br>
 *    &emsp;private Long contactId; //foreign key to Contact<br>
 *    <br>
 *    &emsp;public Person {<br>
 *    &emsp;}<br>
 *    <br>
 *    &emsp;//getters and setters ...<br>
 *    }<br>
 *    <br>
 * </div>
 * </li>
 * <li>Wrap the Person class in a Meta Type:
 * <div>
 *    //store as a constant to reference later<br>
 *    public static final Type&lt;Person&gt; TYPE_PERSON = Type.meta(Person::new)<br>
 *    &emsp;&emsp;//add properties with parameters [columnName, columnType, getter, setter]<br>
 *    &emsp;&emsp;.add("ID", Long.class, Person::getId, Person::setId)<br>
 *    &emsp;&emsp;.add("NAME", String.class, Person::getName, Person::setName)<br>
 *    &emsp;&emsp;//map column "SURNAME" to Person.lastName field via its getter-setter pair<br>
 *    &emsp;&emsp;.add("SURNAME", String.class, Person::getLastName, Person::setLastName)<br>
 *    &emsp;&emsp;.add("DATE_OF_BIRTH", Date.class, Person::getBirthDate, Person::setBirthDate)<br>
 *    &emsp;&emsp;.add("CONTACT_FK", Long.class, Person::getContactId, Person::setContactId);<br>
 * </div>
 * </li>
 * <li>Register the Meta Type CRUD Repository: A database table association to a Java class
 * <div>
 *    &emsp;&emsp;String tableName = "PERSONS";<br>
 *    &emsp;&emsp;int autoGeneratedKeys = java.sql.Statement.RETURN_GENERATED_KEYS;<br>
 *    &emsp;&emsp;MetaRepo&lt;Person&gt; metaRepo = mpa.register(TYPE_PERSON, tableName, autoGeneratedKeys);<br>
 * </div>
 * </li>
 * <li>All set and ready to go. To associate more classes to table repositories repeat these steps.
 * </ol>
 * To create, read, update and delete table records as Java object instances:
 * <ul>
 * <li>SELECT: 
 *    <ul>
 *    <li>Single Result: Person person = mpa.findById(Person.class, 1234L);
 *    <li>Result List: List&lt;Person&gt; persons = mpa.findBy(criteria, Arrays.asList("SURNAME"));
 *    </ul>
 * </li> 
 * <li>INSERT: mpa.persist(person); //inserts a new record in the table
 * <li>UPDATE: mpa.merge(person); //save or update finds the existing record by its primary key and persists the record
 * <li>DELETE: mpa.remove(person); //finds the existing record by its primary key and deletes the record
 * </ul>
 * 
 * @author Dewald Pretorius
 */
public class MPA extends Repository {

   protected String sqlDelimiter = "\"";
   protected Supplier<Connection> connector;
   protected Transaction transaction;
   protected Map<Class<?>, MetaRepo<?>> typedRepoMap = new HashMap<>();
   protected Map<String, Query> queryMap = new HashMap<>();

   /**
    * Creates a Meta Persistence API with a connection provider.
    * 
    * @param connector connection provider
    */
   public MPA(Supplier<Connection> connector) {
      this.connector = connector;
   }

   /**
    * Creates a Meta Persistence API with a custom <code>transaction</code> manager as connnection provider.
    * 
    * @param transaction connection manager
    */
   public MPA(Transaction transaction) {
      connector = transaction;
      this.transaction = transaction;
   }

   /**
    * Returns an opened connection. There is no need to keep local references to this connection and it is strongly
    * advised against doing so. When the current {@link Thread} is associated with an ongoing transaction, it creates
    * an affinity to the connection which started it. As long as the transaction is active this method will always 
    * return the same connection.
    * 
    * @return connection
    */
   public Connection connection() {
      return connector.get();
   }
   
   public void close() {
      if (transaction == connector) transaction.close();
   }

   /**
    * Starts a new transaction. This has no affect when the current {@link Thread} is already associated with a 
    * transaction.
    * 
    * @return connection
    */
   public synchronized Connection beginTransaction() {
      if (transaction == connector) return transaction.begin();

      transaction = new TransactionManager(connector);
      connector = transaction;

      return transaction.begin();
   }

   /**
    * Creates a new rollback save point in the transaction. If no transaction exists for the current {@link Thread} a 
    * new transaction will be created.
    * 
    * @return savepoint reference to {@link MPA#rollback(Savepoint)} to.
    */
   public Savepoint setSavepoint() {
      if (transaction == connector) return transaction.setSavePoint();

      beginTransaction();
      return transaction.setSavePoint();
   }

   /**
    * Rollback the changes effected in this transaction to its last {@link Savepoint}.
    */
   public void rollback() {
      if (transaction == connector) transaction.rollback();
   }

   /**
    * Rollback the changes effected in this transaction to this last {@link Savepoint}.
    * 
    * @param savepoint to rollback to
    */
   public void rollback(Savepoint savepoint) {
      if (transaction == connector) transaction.rollback(savepoint);
   }

   /**
    * Commits the changes effected in this transaction to the database. This will release the the dedicated connection.
    */
   public void commit() {
      if (transaction == connector) transaction.commit();
   }

   /**
    * Creates a blob from the binary byte array.
    * 
    * @param binary bytes
    * @return blob
    */
   public Blob createBlob(byte[] binary) {
      try {
         Blob blob = connection().createBlob();
         blob.setBytes(1, binary);
         return blob;
      } catch (SQLException sqle) {
         rollback();
         throw new RuntimeException("Error creating blob", sqle);
      }
   }

   /**
    * Extracts a binary byte array from the blob.
    * 
    * @param blob sql object
    * @return bytes;
    */
   public byte[] extractBinary(Blob blob) {
      try {
         return blob.getBytes(1, (int) blob.length());
      } catch (SQLException sqle) {
         rollback();
         throw new RuntimeException("Error extracting blob", sqle);
      }
   }

   /**
    * Registers a Meta {@link Type} table repository.
    * 
    * @param <M> metaType
    * @param type meta
    * @param autoGeneratedKeys [{@link Statement#RETURN_GENERATED_KEYS}, {@link Statement#NO_GENERATED_KEYS}]
    * @return metaRepo
    */
   public <M> MetaRepo<M> register(Type<M> type, int autoGeneratedKeys) {
      return register(type, type.getMetaClass().getSimpleName(), autoGeneratedKeys);
   }

   /**
    * Registers a Meta {@link Type} table repository.
    * 
    * @param <M> metaType
    * @param type meta
    * @param tableName of the database table
    * @param autoGeneratedKeys [{@link Statement#RETURN_GENERATED_KEYS}, {@link Statement#NO_GENERATED_KEYS}]
    * @return metaRepo
    */
   public <M> MetaRepo<M> register(Type<M> type, String tableName, int autoGeneratedKeys) {
      List<String> pkColumns = Arrays.asList(type.getPropertyNames().iterator().next());
      return register(type, tableName, pkColumns, autoGeneratedKeys);
   }

   /**
    * Registers a Meta {@link Type} table repository.
    * 
    * @param <M> metaType
    * @param type meta
    * @param tableName of the database table
    * @param pkColumns primary key columns
    * @param autoGeneratedKeys [{@link Statement#RETURN_GENERATED_KEYS}, {@link Statement#NO_GENERATED_KEYS}]
    * @return metaRepo
    */
   public <M> MetaRepo<M> register(Type<M> type, String tableName, List<String> pkColumns, int autoGeneratedKeys) {
      List<String> columns = type.getPropertyNames().stream().collect(toList());
      String selectAll = SQL.select(sqlDelimiter, columns) + "FROM " + tableName;
      String where = SQL.where(sqlDelimiter, pkColumns);
      String findByIdSQL = selectAll + where;

      boolean setAutoGenKeys = Statement.RETURN_GENERATED_KEYS == autoGeneratedKeys;
      columns = type.getPropertyNames().stream().filter(column -> !(setAutoGenKeys && pkColumns.contains(column)))
                                                .collect(toList());
      String insertSQL = SQL.insert(tableName, sqlDelimiter, columns);

      return register(type, tableName, pkColumns, autoGeneratedKeys, selectAll, findByIdSQL, insertSQL);
   }

   /**
    * Registers a Meta {@link Type} table repository.
    * 
    * @param <M> metaType
    * @param type meta
    * @param tableName of the database table
    * @param pkColumns primary key columns
    * @param autoGeneratedKeys [{@link Statement#RETURN_GENERATED_KEYS}, {@link Statement#NO_GENERATED_KEYS}]
    * @param selectSQL parameterised SQL query which will return a {@link ResultSet} 
    * @param findByIdSQL parameterised SQL query which will return a single or zero row {@link ResultSet}
    * @param insertSQL parameterised SQL INSERT statement 
    * @return metaRepo
    */
   public <M> MetaRepo<M> register(Type<M> type, String tableName, List<String> pkColumns, int autoGeneratedKeys,
         String selectSQL, String findByIdSQL, String insertSQL) {
      boolean autoGenKeys = Statement.RETURN_GENERATED_KEYS == autoGeneratedKeys;
      MetaRepo<M> repo = new MetaRepo<>(() -> connection(), type, tableName, pkColumns, autoGenKeys, 
                                        selectSQL, findByIdSQL, insertSQL);
      typedRepoMap.put(type.getMetaClass(), repo);

      return repo;
   }

   /**
    * Returns the meta repository for the <code>prototype</code>.
    * 
    * @param <M> metaType
    * @param prototype instance
    * @return metaRepo
    */
   @SuppressWarnings("unchecked")
   public <M> MetaRepo<M> getMetaRepo(M prototype) {
      Class<M> metaClass = (Class<M>) prototype.getClass();
      return getMetaRepo(metaClass);
   }

   /**
    * Returns the meta repository for the <code>metaClass</code>.
    * 
    * @param <M> metaType
    * @param metaClass type
    * @return metaRepo
    */
   @SuppressWarnings("unchecked") 
   public <M> MetaRepo<M> getMetaRepo(Class<M> metaClass) {
      MetaRepo<M> repo = (MetaRepo<M>) typedRepoMap.get(metaClass);
      if (repo != null) return repo;

      for (Entry<Class<?>, MetaRepo<?>> entry : typedRepoMap.entrySet()) {
         if (metaClass.isAssignableFrom(entry.getKey())) return (MetaRepo<M>) entry.getValue();
      }

      return null;
   }

   /**
    * Inserts a new record into the database table associated with the class type of the parameter instance.
    * 
    * @param <M> metaType
    * @param record instance
    * @return persistedRecord
    */
   public <M> M persist(M record) {
      MetaRepo<M> repo = getMetaRepo(record);
      if (repo == null) return null;
      return persist(repo, record);
   }

   protected <M> M persist(MetaRepo<M> repo, M record) {
      PreparedStatement insert = repo.getQuery(INSERT).get();

      try {
         synchronized (insert) {
            List<String> columns = repo.type.getPropertyNames().stream() 
                                            .filter(column -> !(repo.setAutoGenKeys && repo.pkColumns.contains(column)))
                                            .collect(toList());
            load(insert, columns, repo.type, record);

            int count = insert.executeUpdate();
            if (!repo.setAutoGenKeys) return count == 1 ? record : null;

            try (ResultSet resultSet = insert.getGeneratedKeys();) {
               for (String column : repo.pkColumns) {
                  if (!resultSet.next()) break;
                  Object primaryKey = resultSet.getObject(column);
                  Property<M, Object> property = repo.type.getProperty(column);

                  property.set.accept(record, primaryKey);
               }
            }

            return record;
         }
      } catch (SQLException sqle) {
         rollback();
         String message = "Error persisting " + repo.metaClass.getSimpleName() + " into Table " + repo.tableName;
         throw new RuntimeException(message, sqle);
      }
   }

   /**
    * Finds and returns a single record by its primary key as an instance of the metaClass parameter.
    * 
    * @param <M> metaType
    * @param metaClass type
    * @param primaryKey values
    * @return foundRecord or null when no meta repository was registered for the input class 
    */
   public <M> Optional<M> findById(Class<M> metaClass, Object... primaryKey) {
      MetaRepo<M> repo = getMetaRepo(metaClass);
      if (repo == null) return null;
      return findById(repo, primaryKey);
   }

   protected <M> Optional<M> findById(MetaRepo<M> repo, Object... primaryKey) {
      M record = repo.type.create();

      for (int index = 0; index < primaryKey.length; index++) {
         String column = repo.pkColumns.get(index);
         Property<M, Object> property = repo.type.getProperty(column);
         property.set.accept(record, primaryKey[index]);
      }

      return findById(repo, record);
   }

   protected <M> Optional<M> findById(MetaRepo<M> repo, M record) {
      try (ResultSet resultSet = executeQuery(repo.getQuery(FIND_BY_ID).get(), repo.pkColumns, repo.type, record);) {
         List<M> list = extract(resultSet, repo.type);
         return list.stream().findFirst();
      } catch (SQLException sqle) {
         rollback();
         String message = "Error finding " + repo.metaClass.getSimpleName() + 
                          " record by Id from Table " + repo.tableName;
         throw new RuntimeException(message, sqle);
      }
   }

   /**
    * Finds all records for the associated database table and return them as a list of the metaClass instances.
    * 
    * @param <M> metaType
    * @param metaClass type
    * @return resultList or null when no meta repository was registered for the input class 
    */
   public <M> List<M> findAll(Class<M> metaClass) {
      MetaRepo<M> repo = getMetaRepo(metaClass);
      if (repo == null) return null;
      return findAll(repo);
   }

   protected <M> List<M> findAll(MetaRepo<M> repo) {
      try (PreparedStatement statement = repo.getQuery(FIND_ALL).get();
           ResultSet resultSet = statement.executeQuery();) {
         return extract(resultSet, repo.type);
      } catch (SQLException sqle) {
         rollback();
         String message = "Error retrieving all " + repo.metaClass.getSimpleName() + " from Table " + repo.tableName;
         throw new RuntimeException(message, sqle);
      }
   }

   /**
    * Finds matching criteria records for the associated database table and return them as a list of the metaClass 
    * instances.
    * 
    * @param <M> metaType
    * @param criteria instance
    * @param propertyNames which need to be loaded from the <code>criteria</code>
    * @return resultList or null when no meta repository was registered for the input class 
    */
   public <M> List<M> findBy(M criteria, List<String> propertyNames) {
      MetaRepo<M> repo = getMetaRepo(criteria);
      if (repo == null) return null;
      return findBy(repo, criteria, propertyNames);
   }

   protected <M> List<M> findBy(MetaRepo<M> repo, M criteria, List<String> columns) {
      String where = SQL.where(sqlDelimiter, columns);
      String findBySQL = repo.selectSQL + where;
      PreparedStatement statement = repo.setQuery(where, findBySQL).get(); //don't close statement, cache it
      
      try (ResultSet resultSet = executeQuery(statement, columns, repo.type, criteria);) {
         return extract(resultSet, repo.type);
      } catch (SQLException sqle) {
         rollback();
         throw new RuntimeException("Error finding by SQL:" + findBySQL, sqle);
      }
   }

   /**
    * Save or update an existing database table record.
    * 
    * @param <M> metaType
    * @param record instance
    * @return mergedRecord
    */
   public <M> M merge(M record) {
      MetaRepo<M> repo = getMetaRepo(record);
      if (repo == null) return null;
      return merge(repo, record);
   }

   protected <M> M merge(MetaRepo<M> repo, M record) {
      PreparedStatement findById = repo.getQuery(FIND_BY_ID).get();

      try (ResultSet resultSet = executeQuery(findById, repo.pkColumns, repo.type, record);) {
         Map<String, String> columnPropertyMap = 
               repo.type.getPropertyNames().stream().collect(toMap(identity(), identity()));
         List<M> updated = update(resultSet, repo.type, record, columnPropertyMap);
         if (!updated.isEmpty()) return updated.get(0);
         return persist(record);
      } catch (SQLException sqle) {
         rollback();
         String message = "Error merging " + repo.metaClass.getSimpleName() + 
                          " record by Id from Table " + repo.tableName;
         throw new RuntimeException(message, sqle);
      }
   }

   /**
    * Deletes a single database table record.
    * 
    * @param <M> metaType
    * @param record instance
    * @return removed record or null if it wasn't found
    */
   public <M> M remove(M record) {
      MetaRepo<M> repo = getMetaRepo(record);
      if (repo == null) return null;

      PreparedStatement findById = repo.getQuery(FIND_BY_ID).get();

      try (ResultSet resultSet = executeQuery(findById, repo.pkColumns, repo.type, record);) {
         List<M> removed = delete(resultSet, repo.type);
         if (removed.isEmpty()) return null;
         return removed.get(0);
      } catch (SQLException sqle) {
         rollback();
         String message = "Error removing " + repo.metaClass.getSimpleName() + 
                          " record by Id from Table " + repo.tableName; 
         throw new RuntimeException(message, sqle);
      }
   }
   
   /**
    * Deletes a single database table record by its primary key.
    * 
    * @param <M> metaType
    * @param metaClass type
    * @param primaryKey or combined primary key objects
    * @return removed record or null if it wasn't found
    */
   public <M> M removeById(Class<M> metaClass, Object... primaryKey) {
      MetaRepo<M> repo = getMetaRepo(metaClass);
      if (repo == null) return null;
      
      PreparedStatement findById = repo.getQuery(FIND_BY_ID).get();

      try (ResultSet resultSet = executeQuery(findById, primaryKey);) {
         List<M> removed = delete(resultSet, repo.type);
         if (removed.isEmpty()) return null;
         return removed.get(0);
      } catch (SQLException sqle) {
         rollback();
         String message = "Error removing " + repo.metaClass.getSimpleName() + 
                          " record by Id from Table " + repo.tableName; 
         throw new RuntimeException(message, sqle);
      }
   }

   /**
    * Returns the SQL delimiter that will be used to generate the basic queries when registering meta types.
    * 
    * @return sqlDelimiter
    */
   public String getSqlDelimiter() {
      return sqlDelimiter;
   }

   /**
    * Sets the SQL delimiter that will be used to generate the basic queries when registering meta types.
    * 
    * @param sqlDelimiter to delimit column and table names
    */
   public void setSqlDelimiter(String sqlDelimiter) {
      this.sqlDelimiter = sqlDelimiter;
   }
   
   /**
    * Creates an ad hoc named cached query.
    * 
    * @param name alias of the query
    * @param sql to create a cahced {@link PreparedStatement}
    * @return query
    */
   public Query setQuery(String name, String sql) {
      return queryMap.computeIfAbsent(name, key -> QueryFunction.simpleQuery(connector, sql));
   }
   
   /**
    * Retrieves a named cached query by its alias.
    * 
    * @param name alias of the query
    * @return query
    */
   public Query getQuery(String name) {
      return queryMap.get(name);
   }
}
